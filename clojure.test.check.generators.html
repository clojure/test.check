<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>clojure.test.check.generators documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Test.check</span> <span class="project-version">0.10.0-alpha4</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="api-docs-for-older-versions.html"><div class="inner"><span>API Docs for Older Versions</span></div></a></li><li class="depth-1 "><a href="cheatsheet.html"><div class="inner"><span>test.check cheatsheet</span></div></a></li><li class="depth-1 "><a href="generator-examples.html"><div class="inner"><span>Generator Examples</span></div></a></li><li class="depth-1 "><a href="growth-and-shrinking.html"><div class="inner"><span>Growth and Shrinking</span></div></a></li><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to test.check</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></div></li><li class="depth-3"><a href="clojure.test.check.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>check</span></div></a></li><li class="depth-4 branch"><a href="clojure.test.check.clojure-test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure-test</span></div></a></li><li class="depth-4 branch current"><a href="clojure.test.check.generators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generators</span></div></a></li><li class="depth-4 branch"><a href="clojure.test.check.properties.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>properties</span></div></a></li><li class="depth-4"><a href="clojure.test.check.results.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>results</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="clojure.test.check.generators.html#var-any"><div class="inner"><span>any</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-any-printable"><div class="inner"><span>any-printable</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-bind"><div class="inner"><span>bind</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-boolean"><div class="inner"><span>boolean</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-byte"><div class="inner"><span>byte</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-bytes"><div class="inner"><span>bytes</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-char"><div class="inner"><span>char</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-char-alpha"><div class="inner"><span>char-alpha</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-char-alpha-numeric"><div class="inner"><span>char-alpha-numeric</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-char-alphanumeric"><div class="inner"><span>char-alphanumeric</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-char-ascii"><div class="inner"><span>char-ascii</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-choose"><div class="inner"><span>choose</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-container-type"><div class="inner"><span>container-type</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-double"><div class="inner"><span>double</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-double*"><div class="inner"><span>double*</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-elements"><div class="inner"><span>elements</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-fmap"><div class="inner"><span>fmap</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-frequency"><div class="inner"><span>frequency</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-generate"><div class="inner"><span>generate</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-generator.3F"><div class="inner"><span>generator?</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-hash-map"><div class="inner"><span>hash-map</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-int"><div class="inner"><span>int</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-keyword"><div class="inner"><span>keyword</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-keyword-ns"><div class="inner"><span>keyword-ns</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-large-integer"><div class="inner"><span>large-integer</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-large-integer*"><div class="inner"><span>large-integer*</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-lazy-random-states"><div class="inner"><span>lazy-random-states</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-let"><div class="inner"><span>let</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-list"><div class="inner"><span>list</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-list-distinct"><div class="inner"><span>list-distinct</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-list-distinct-by"><div class="inner"><span>list-distinct-by</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-map"><div class="inner"><span>map</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-nat"><div class="inner"><span>nat</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-neg-int"><div class="inner"><span>neg-int</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-no-shrink"><div class="inner"><span>no-shrink</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-not-empty"><div class="inner"><span>not-empty</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-one-of"><div class="inner"><span>one-of</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-pos-int"><div class="inner"><span>pos-int</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-ratio"><div class="inner"><span>ratio</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-recursive-gen"><div class="inner"><span>recursive-gen</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-resize"><div class="inner"><span>resize</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-return"><div class="inner"><span>return</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-s-neg-int"><div class="inner"><span>s-neg-int</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-s-pos-int"><div class="inner"><span>s-pos-int</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-sample"><div class="inner"><span>sample</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-sample-seq"><div class="inner"><span>sample-seq</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-scale"><div class="inner"><span>scale</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-set"><div class="inner"><span>set</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-shrink-2"><div class="inner"><span>shrink-2</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-shuffle"><div class="inner"><span>shuffle</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-simple-type"><div class="inner"><span>simple-type</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-simple-type-printable"><div class="inner"><span>simple-type-printable</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-sized"><div class="inner"><span>sized</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-sorted-set"><div class="inner"><span>sorted-set</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-string"><div class="inner"><span>string</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-string-alpha-numeric"><div class="inner"><span>string-alpha-numeric</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-string-alphanumeric"><div class="inner"><span>string-alphanumeric</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-string-ascii"><div class="inner"><span>string-ascii</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-such-that"><div class="inner"><span>such-that</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-symbol"><div class="inner"><span>symbol</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-symbol-ns"><div class="inner"><span>symbol-ns</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-tuple"><div class="inner"><span>tuple</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-uuid"><div class="inner"><span>uuid</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-vector"><div class="inner"><span>vector</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-vector-distinct"><div class="inner"><span>vector-distinct</span></div></a></li><li class="depth-1"><a href="clojure.test.check.generators.html#var-vector-distinct-by"><div class="inner"><span>vector-distinct-by</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">clojure.test.check.generators</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-any"><h3>any</h3><div class="usage"></div><div class="doc"><pre class="plaintext">A recursive generator that will generate many different, often nested, values
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1558">view source</a></div></div><div class="public anchor" id="var-any-printable"><h3>any-printable</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Like any, but avoids characters that the shell will interpret as actions,
like 7 and 14 (bell and alternate character set command)</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1562">view source</a></div></div><div class="public anchor" id="var-bind"><h3>bind</h3><div class="usage"><code>(bind generator f)</code></div><div class="doc"><pre class="plaintext">Create a new generator that passes the result of `gen` into function
`f`. `f` should return a new generator. This allows you to create new
generators that depend on the value of other generators. For example,
to create a generator of permutations which first generates a
`num-elements` and then generates a shuffling of `(range num-elements)`:

    (gen/bind gen/nat
              ;; this function takes a value generated by
              ;; the generator above and returns a new generator
              ;; which shuffles the collection returned by `range`
              (fn [num-elements]
                (gen/shuffle (range num-elements))))

Also see gen/let for a macro with similar functionality.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L124">view source</a></div></div><div class="public anchor" id="var-boolean"><h3>boolean</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generates one of `true` or `false`. Shrinks to `false`.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L500">view source</a></div></div><div class="public anchor" id="var-byte"><h3>byte</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generates `java.lang.Byte`s, using the full byte-range.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L615">view source</a></div></div><div class="public anchor" id="var-bytes"><h3>bytes</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generates byte-arrays.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L620">view source</a></div></div><div class="public anchor" id="var-char"><h3>char</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generates character from 0-255.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1262">view source</a></div></div><div class="public anchor" id="var-char-alpha"><h3>char-alpha</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generate alpha characters.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1284">view source</a></div></div><div class="public anchor" id="var-char-alpha-numeric"><h3>char-alpha-numeric</h3><h4 class="deprecated">deprecated in 0.6.0</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Deprecated - use char-alphanumeric instead.

Generate alphanumeric characters.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1277">view source</a></div></div><div class="public anchor" id="var-char-alphanumeric"><h3>char-alphanumeric</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generate alphanumeric characters.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1270">view source</a></div></div><div class="public anchor" id="var-char-ascii"><h3>char-ascii</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generate only ascii character.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1266">view source</a></div></div><div class="public anchor" id="var-choose"><h3>choose</h3><div class="usage"><code>(choose lower upper)</code></div><div class="doc"><pre class="plaintext">Create a generator that returns long integers in the range
`lower` to `upper`, inclusive.

    (gen/sample (gen/choose 200 800))
    =&gt; (331 241 593 339 643 718 688 473 247 694)</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L298">view source</a></div></div><div class="public anchor" id="var-container-type"><h3>container-type</h3><div class="usage"><code>(container-type inner-type)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1450">view source</a></div></div><div class="public anchor" id="var-double"><h3>double</h3><h4 class="added">added in 0.9.0</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Generates 64-bit floating point numbers from the entire range,
including +/- infinity and NaN. Use double* for more control.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1254">view source</a></div></div><div class="public anchor" id="var-double*"><h3>double*</h3><h4 class="added">added in 0.9.0</h4><div class="usage"><code>(double* {:keys [infinite? NaN? min max], :or {infinite? true, NaN? true}})</code></div><div class="doc"><pre class="plaintext">Generates a 64-bit floating point number. Options:

  :infinite? - whether +/- infinity can be generated (default true)
  :NaN?      - whether NaN can be generated (default true)
  :min       - minimum value (inclusive, default none)
  :max       - maximum value (inclusive, default none)

Note that the min/max options must be finite numbers. Supplying a
min precludes -Infinity, and supplying a max precludes +Infinity.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1212">view source</a></div></div><div class="public anchor" id="var-elements"><h3>elements</h3><div class="usage"><code>(elements coll)</code></div><div class="doc"><pre class="plaintext">Create a generator that randomly chooses an element from `coll`.

(gen/sample (gen/elements [:foo :bar :baz]))
=&gt; (:foo :baz :baz :bar :foo :foo :bar :bar :foo :bar)</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L390">view source</a></div></div><div class="public anchor" id="var-fmap"><h3>fmap</h3><div class="usage"><code>(fmap f gen)</code></div><div class="doc"><pre class="plaintext">Returns a generator like `gen` but with values transformed by `f`.
E.g.:

    (gen/sample (gen/fmap str gen/nat))
    =&gt; ("0" "1" "0" "1" "4" "3" "6" "6" "4" "2")

Also see gen/let for a macro with similar functionality.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L93">view source</a></div></div><div class="public anchor" id="var-frequency"><h3>frequency</h3><div class="usage"><code>(frequency pairs)</code></div><div class="doc"><pre class="plaintext">Create a generator that chooses a generator from `pairs` based on the
provided likelihoods. The likelihood of a given generator being chosen is
its likelihood divided by the sum of all likelihoods. Shrinks toward
choosing an earlier generator, as well as shrinking the value generated
by the chosen generator.

Examples:

    (gen/sample (gen/frequency [[5 gen/int] [3 (gen/vector gen/int)] [2 gen/boolean]]))
    =&gt; (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L351">view source</a></div></div><div class="public anchor" id="var-generate"><h3>generate</h3><h4 class="added">added in 0.8.0</h4><div class="usage"><code>(generate generator)</code><code>(generate generator size)</code><code>(generate generator size seed)</code></div><div class="doc"><pre class="plaintext">Returns a single sample value from the generator.

Note that this function is a dev helper and is not meant to be used
to build other generators.

Optional args:

- size: the abstract size parameter, defaults to 30
- seed: the seed for the random number generator, an integer</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L178">view source</a></div></div><div class="public anchor" id="var-generator.3F"><h3>generator?</h3><div class="usage"><code>(generator? x)</code></div><div class="doc"><pre class="plaintext">Test if `x` is a generator. Generators should be treated as opaque values.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L30">view source</a></div></div><div class="public anchor" id="var-hash-map"><h3>hash-map</h3><div class="usage"><code>(hash-map &amp; kvs)</code></div><div class="doc"><pre class="plaintext">Like clojure.core/hash-map, except the values are generators.
Returns a generator that makes maps with the supplied keys and
values generated using the supplied generators.

    (gen/sample (gen/hash-map :a gen/boolean :b gen/nat))
    =&gt; ({:a false, :b 0}
        {:a true,  :b 1}
        {:a false, :b 2}
        {:a true,  :b 2}
        {:a false, :b 4}
        {:a false, :b 2}
        {:a true,  :b 3}
        {:a true,  :b 4}
        {:a false, :b 1}
        {:a false, :b 0})</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L624">view source</a></div></div><div class="public anchor" id="var-int"><h3>int</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generates a positive or negative integer bounded by the generator's
`size` parameter.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L522">view source</a></div></div><div class="public anchor" id="var-keyword"><h3>keyword</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generate keywords without namespaces.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1357">view source</a></div></div><div class="public anchor" id="var-keyword-ns"><h3>keyword-ns</h3><h4 class="added">added in 0.5.9</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Generate keywords with namespaces.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1365">view source</a></div></div><div class="public anchor" id="var-large-integer"><h3>large-integer</h3><h4 class="added">added in 0.9.0</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Generates a platform-native integer from the full available range
(in clj, 64-bit Longs, and in cljs, numbers between -(2^53 - 1) and
(2^53 - 1)).

Use large-integer* for more control.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1020">view source</a></div></div><div class="public anchor" id="var-large-integer*"><h3>large-integer*</h3><h4 class="added">added in 0.9.0</h4><div class="usage"><code>(large-integer* {:keys [min max]})</code></div><div class="doc"><pre class="plaintext">Like large-integer, but accepts options:

  :min  the minimum integer (inclusive)
  :max  the maximum integer (inclusive)

Both :min and :max are optional.

    (gen/sample (gen/large-integer* {:min 9000 :max 10000}))
    =&gt; (9000 9001 9001 9002 9000 9003 9006 9030 9005 9044)</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L998">view source</a></div></div><div class="public anchor" id="var-lazy-random-states"><h3>lazy-random-states</h3><div class="usage"><code>(lazy-random-states rr)</code></div><div class="doc"><pre class="plaintext">Internal function.

Given a random number generator, returns an infinite lazy sequence
of random number generators.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L72">view source</a></div></div><div class="public anchor" id="var-let"><h3>let</h3><h4 class="type">macro</h4><h4 class="added">added in 0.9.0</h4><div class="usage"><code>(let bindings &amp; body)</code></div><div class="doc"><pre class="plaintext">Macro for building generators using values from other generators.
Uses a binding vector with the same syntax as clojure.core/let,
where the right-hand side of the binding pairs are generators, and
the left-hand side are names (or destructuring forms) for generated
values.

Subsequent generator expressions can refer to the previously bound
values, in the same way as clojure.core/let.

The body of the let can be either a value or a generator, and does
the expected thing in either case. In this way let provides the
functionality of both `bind` and `fmap`.

Examples:

  (gen/let [strs (gen/not-empty (gen/list gen/string))
            s (gen/elements strs)]
    {:some-strings strs
     :one-of-those-strings s})

  ;; generates collections of "users" that have integer IDs
  ;; from 0...N-1, but are in a random order
  (gen/let [users (gen/list (gen/hash-map :name gen/string-ascii
                                          :age gen/nat))]
    (-&gt;&gt; users
         (map #(assoc %2 :id %1) (range))
         (gen/shuffle)))</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1570">view source</a></div></div><div class="public anchor" id="var-list"><h3>list</h3><div class="usage"><code>(list generator)</code></div><div class="doc"><pre class="plaintext">Like `vector`, but generates lists.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L579">view source</a></div></div><div class="public anchor" id="var-list-distinct"><h3>list-distinct</h3><h4 class="added">added in 0.9.0</h4><div class="usage"><code>(list-distinct gen)</code><code>(list-distinct gen opts)</code></div><div class="doc"><pre class="plaintext">Generates a list of elements from the given generator, with the
guarantee that the elements will be distinct.

If the generator cannot or is unlikely to produce enough distinct
elements, this generator will fail in the same way as `such-that`.

Available options:

  :num-elements  the fixed size of generated list
  :min-elements  the min size of generated list
  :max-elements  the max size of generated list
  :max-tries     the number of times the generator will be tried before
                 failing when it does not produce distinct elements
                 (default 10)
  :ex-fn         a function of one arg that will be called if test.check cannot
                 generate enough distinct values; it will be passed a map with
                 `:gen`, `:num-elements`, and `:max-tries` and should return an
                 exception</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L799">view source</a></div></div><div class="public anchor" id="var-list-distinct-by"><h3>list-distinct-by</h3><h4 class="added">added in 0.9.0</h4><div class="usage"><code>(list-distinct-by key-fn gen)</code><code>(list-distinct-by key-fn gen opts)</code></div><div class="doc"><pre class="plaintext">Generates a list of elements from the given generator, with the
guarantee that (map key-fn the-list) will be distinct.

If the generator cannot or is unlikely to produce enough distinct
elements, this generator will fail in the same way as `such-that`.

Available options:

  :num-elements  the fixed size of generated list
  :min-elements  the min size of generated list
  :max-elements  the max size of generated list
  :max-tries     the number of times the generator will be tried before
                 failing when it does not produce distinct elements
                 (default 10)
  :ex-fn         a function of one arg that will be called if test.check cannot
                 generate enough distinct values; it will be passed a map with
                 `:gen`, `:num-elements`, and `:max-tries` and should return an
                 exception</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L849">view source</a></div></div><div class="public anchor" id="var-map"><h3>map</h3><div class="usage"><code>(map key-gen val-gen)</code><code>(map key-gen val-gen opts)</code></div><div class="doc"><pre class="plaintext">Create a generator that generates maps, with keys chosen from
`key-gen` and values chosen from `val-gen`.

If the key generator cannot or is unlikely to produce enough distinct
elements, this generator will fail in the same way as `such-that`.

Available options:

  :num-elements  the fixed size of generated maps
  :min-elements  the min size of generated maps
  :max-elements  the max size of generated maps
  :max-tries     the number of times the generator will be tried before
                 failing when it does not produce distinct elements
                 (default 10)
  :ex-fn         a function of one arg that will be called if test.check cannot
                 generate enough distinct keys; it will be passed a map with
                 `:gen` (the key-gen), `:num-elements`, and `:max-tries` and
                 should return an exception</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L922">view source</a></div></div><div class="public anchor" id="var-nat"><h3>nat</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generates non-negative integers bounded by the generator's `size`
parameter. Shrinks to zero.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L527">view source</a></div></div><div class="public anchor" id="var-neg-int"><h3>neg-int</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generate negative integers bounded by the generator's `size` parameter.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L536">view source</a></div></div><div class="public anchor" id="var-no-shrink"><h3>no-shrink</h3><div class="usage"><code>(no-shrink gen)</code></div><div class="doc"><pre class="plaintext">Create a new generator that is just like `gen`, except does not shrink
at all. This can be useful when shrinking is taking a long time or is not
applicable to the domain.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L483">view source</a></div></div><div class="public anchor" id="var-not-empty"><h3>not-empty</h3><div class="usage"><code>(not-empty gen)</code></div><div class="doc"><pre class="plaintext">Modifies a generator so that it doesn't generate empty collections.

Examples:

    ;; generate a vector of booleans, but never the empty vector
    (gen/sample (gen/not-empty (gen/vector gen/boolean)))
    =&gt; ([false]
        [false false]
        [false false]
        [false false false]
        [false false false false]
        [false true true]
        [true false false false]
        [true]
        [true true true false false true false]
        [false true true true false true true true false])</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L462">view source</a></div></div><div class="public anchor" id="var-one-of"><h3>one-of</h3><div class="usage"><code>(one-of generators)</code></div><div class="doc"><pre class="plaintext">Create a generator that randomly chooses a value from the list of
provided generators. Shrinks toward choosing an earlier generator,
as well as shrinking the value generated by the chosen generator.

    (gen/sample (gen/one-of [gen/int gen/boolean (gen/vector gen/int)]))
    =&gt; (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L327">view source</a></div></div><div class="public anchor" id="var-pos-int"><h3>pos-int</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generate positive integers bounded by the generator's `size` parameter.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L532">view source</a></div></div><div class="public anchor" id="var-ratio"><h3>ratio</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generates a `clojure.lang.Ratio`. Shrinks toward 0. Not all values generated
will be ratios, as many values returned by `/` are not ratios.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1389">view source</a></div></div><div class="public anchor" id="var-recursive-gen"><h3>recursive-gen</h3><h4 class="added">added in 0.5.9</h4><div class="usage"><code>(recursive-gen container-gen-fn scalar-gen)</code></div><div class="doc"><pre class="plaintext">This is a helper for writing recursive (tree-shaped) generators. The first
argument should be a function that takes a generator as an argument, and
produces another generator that 'contains' that generator. The vector function
in this namespace is a simple example. The second argument is a scalar
generator, like boolean. For example, to produce a tree of booleans:

  (gen/recursive-gen gen/vector gen/boolean)

Vectors or maps either recurring or containing booleans or integers:

  (gen/recursive-gen (fn [inner] (gen/one-of [(gen/vector inner)
                                              (gen/map inner inner)]))
                     (gen/one-of [gen/boolean gen/int]))

Note that raw scalar values will be generated as well. To prevent this, you
can wrap the returned generator with the function passed as the first arg,
e.g.:

  (gen/vector (gen/recursive-gen gen/vector gen/boolean))</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1501">view source</a></div></div><div class="public anchor" id="var-resize"><h3>resize</h3><div class="usage"><code>(resize n generator)</code></div><div class="doc"><pre class="plaintext">Create a new generator with `size` always bound to `n`.

(gen/sample (gen/set (gen/resize 200 gen/double)))
=&gt; (#{}
    #{-4.994772362980037E147}
    #{-4.234418056487335E-146}
    #{}
    #{}
    #{}
    #{NaN}
    #{8.142414100982609E-63}
    #{-3.58429955903876E-159 2.8563794617604296E-154
      4.1021360195776005E-100 1.9084564045332549E-38}
    #{-2.1582818131881376E83 -5.8460065493236117E48 9.729260993803226E166})</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L262">view source</a></div></div><div class="public anchor" id="var-return"><h3>return</h3><div class="usage"><code>(return value)</code></div><div class="doc"><pre class="plaintext">Create a generator that always returns `value`,
and never shrinks. You can think of this as
the `constantly` of generators. E.g.:

    (gen/sample (gen/return 42))
    =&gt; (42 42 42 42 42 42 42 42 42 42)</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L105">view source</a></div></div><div class="public anchor" id="var-s-neg-int"><h3>s-neg-int</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generate strictly negative integers bounded by the generator's `size` + 1
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L544">view source</a></div></div><div class="public anchor" id="var-s-pos-int"><h3>s-pos-int</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generate strictly positive integers bounded by the generator's `size` + 1
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L540">view source</a></div></div><div class="public anchor" id="var-sample"><h3>sample</h3><div class="usage"><code>(sample generator)</code><code>(sample generator num-samples)</code></div><div class="doc"><pre class="plaintext">Return a sequence of `num-samples` (default 10)
realized values from `generator`.

The sequence starts with small values from the generator, which
probably do not reflect the variety of values that will be generated
during a longer test run.

Note that this function is a dev helper and is not meant to be used
to build other generators.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L162">view source</a></div></div><div class="public anchor" id="var-sample-seq"><h3>sample-seq</h3><div class="usage"><code>(sample-seq generator)</code><code>(sample-seq generator max-size)</code></div><div class="doc"><pre class="plaintext">Return a sequence of realized values from `generator`.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L152">view source</a></div></div><div class="public anchor" id="var-scale"><h3>scale</h3><h4 class="added">added in 0.8.0</h4><div class="usage"><code>(scale f generator)</code></div><div class="doc"><pre class="plaintext">Create a new generator that modifies the size parameter by the
given function. Intended to support generators with sizes that need
to grow at different rates compared to the normal linear scaling.

    (gen/sample (gen/tuple (gen/scale #(/ % 10) gen/nat)
                           gen/nat
                           (gen/scale #(* % 10) gen/nat)))
    =&gt; ([0 0 0]  [0 1 2]  [0 2 13] [0 1 6]  [0 1 23]
        [0 2 42] [0 1 26] [0 1 12] [0 1 12] [0 0 3])</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L284">view source</a></div></div><div class="public anchor" id="var-set"><h3>set</h3><h4 class="added">added in 0.9.0</h4><div class="usage"><code>(set gen)</code><code>(set gen opts)</code></div><div class="doc"><pre class="plaintext">Generates a set of elements from the given generator.

If the generator cannot or is unlikely to produce enough distinct
elements, this generator will fail in the same way as `such-that`.

Available options:

  :num-elements  the fixed size of generated set
  :min-elements  the min size of generated set
  :max-elements  the max size of generated set
  :max-tries     the number of times the generator will be tried before
                 failing when it does not produce distinct elements
                 (default 10)
  :ex-fn         a function of one arg that will be called if test.check cannot
                 generate enough distinct values; it will be passed a map with
                 `:gen`, `:num-elements`, and `:max-tries` and should return an
                 exception</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L874">view source</a></div></div><div class="public anchor" id="var-shrink-2"><h3>shrink-2</h3><div class="usage"><code>(shrink-2 gen)</code></div><div class="doc"><pre class="plaintext">Create a new generator like `gen`, but will consider nodes for shrinking
even if their parent passes the test (up to one additional level).</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L493">view source</a></div></div><div class="public anchor" id="var-shuffle"><h3>shuffle</h3><h4 class="added">added in 0.6.0</h4><div class="usage"><code>(shuffle coll)</code></div><div class="doc"><pre class="plaintext">Create a generator that generates random permutations of
`coll`. Shrinks toward the original collection: `coll`. `coll` will
be coerced to a vector.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L595">view source</a></div></div><div class="public anchor" id="var-simple-type"><h3>simple-type</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1432">view source</a></div></div><div class="public anchor" id="var-simple-type-printable"><h3>simple-type-printable</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1436">view source</a></div></div><div class="public anchor" id="var-sized"><h3>sized</h3><div class="usage"><code>(sized sized-gen)</code></div><div class="doc"><pre class="plaintext">Create a generator that depends on the size parameter.
`sized-gen` is a function that takes an integer and returns
a generator.

    TODO: example</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L247">view source</a></div></div><div class="public anchor" id="var-sorted-set"><h3>sorted-set</h3><h4 class="added">added in 0.9.0</h4><div class="usage"><code>(sorted-set gen)</code><code>(sorted-set gen opts)</code></div><div class="doc"><pre class="plaintext">Generates a sorted set of elements from the given generator.

If the generator cannot or is unlikely to produce enough distinct
elements, this generator will fail in the same way as `such-that`.

Available options:

  :num-elements  the fixed size of generated set
  :min-elements  the min size of generated set
  :max-elements  the max size of generated set
  :max-tries     the number of times the generator will be tried before
                 failing when it does not produce distinct elements
                 (default 10)
  :ex-fn         a function of one arg that will be called if test.check cannot
                 generate enough distinct values; it will be passed a map with
                 `:gen`, `:num-elements`, and `:max-tries` and should return an
                 exception</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L898">view source</a></div></div><div class="public anchor" id="var-string"><h3>string</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generate strings. May generate unprintable characters.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1305">view source</a></div></div><div class="public anchor" id="var-string-alpha-numeric"><h3>string-alpha-numeric</h3><h4 class="deprecated">deprecated in 0.6.0</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Deprecated - use string-alphanumeric instead.

Generate alphanumeric strings.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1317">view source</a></div></div><div class="public anchor" id="var-string-alphanumeric"><h3>string-alphanumeric</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generate alphanumeric strings.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1313">view source</a></div></div><div class="public anchor" id="var-string-ascii"><h3>string-ascii</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generate ascii strings.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1309">view source</a></div></div><div class="public anchor" id="var-such-that"><h3>such-that</h3><div class="usage"><code>(such-that pred gen)</code><code>(such-that pred gen max-tries-or-opts)</code></div><div class="doc"><pre class="plaintext">Create a generator that generates values from `gen` that satisfy predicate
`pred`. Care is needed to ensure there is a high chance `gen` will satisfy
`pred`. By default, `such-that` will try 10 times to generate a value that
satisfies the predicate. If no value passes this predicate after this number
of iterations, a runtime exception will be thrown. Note also that each
time such-that retries, it will increase the size parameter.

Examples:

    ;; generate non-empty vectors of integers
    ;; (note, gen/not-empty does exactly this)
    (gen/such-that not-empty (gen/vector gen/int))

You can customize `such-that` by passing an optional third argument, which can
either be an integer representing the maximum number of times test.check
will try to generate a value matching the predicate, or a map:

    :max-tries  positive integer, the maximum number of tries (default 10)
    :ex-fn      a function of one arg that will be called if test.check cannot
                generate a matching value; it will be passed a map with `:gen`,
                `:pred`, and `:max-tries` and should return an exception</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L422">view source</a></div></div><div class="public anchor" id="var-symbol"><h3>symbol</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Generate symbols without namespaces.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1373">view source</a></div></div><div class="public anchor" id="var-symbol-ns"><h3>symbol-ns</h3><h4 class="added">added in 0.5.9</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Generate symbols with namespaces.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1381">view source</a></div></div><div class="public anchor" id="var-tuple"><h3>tuple</h3><div class="usage"><code>(tuple &amp; generators)</code></div><div class="doc"><pre class="plaintext">Create a generator that returns a vector, whose elements are chosen
from the generators in the same position. The individual elements shrink
according to their generator, but the value will never shrink in count.

Examples:

    (def t (tuple gen/int gen/boolean))
    (sample t)
    ;; =&gt; ([1 true] [2 true] [2 false] [1 false] [0 true] [-2 false] [-6 false]
    ;; =&gt;  [3 true] [-4 false] [9 true]))</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L504">view source</a></div></div><div class="public anchor" id="var-uuid"><h3>uuid</h3><h4 class="added">added in 0.9.0</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Generates a random type-4 UUID. Does not shrink.
</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1397">view source</a></div></div><div class="public anchor" id="var-vector"><h3>vector</h3><div class="usage"><code>(vector generator)</code><code>(vector generator num-elements)</code><code>(vector generator min-elements max-elements)</code></div><div class="doc"><pre class="plaintext">Create a generator of vectors whose elements are chosen from
`generator`. The count of the vector will be bounded by the `size`
generator parameter.</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L548">view source</a></div></div><div class="public anchor" id="var-vector-distinct"><h3>vector-distinct</h3><h4 class="added">added in 0.9.0</h4><div class="usage"><code>(vector-distinct gen)</code><code>(vector-distinct gen opts)</code></div><div class="doc"><pre class="plaintext">Generates a vector of elements from the given generator, with the
guarantee that the elements will be distinct.

If the generator cannot or is unlikely to produce enough distinct
elements, this generator will fail in the same way as `such-that`.

Available options:

  :num-elements  the fixed size of generated vectors
  :min-elements  the min size of generated vectors
  :max-elements  the max size of generated vectors
  :max-tries     the number of times the generator will be tried before
                 failing when it does not produce distinct elements
                 (default 10)
  :ex-fn         a function of one arg that will be called if test.check cannot
                 generate enough distinct values; it will be passed a map with
                 `:gen`, `:num-elements`, and `:max-tries` and should return an
                 exception</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L774">view source</a></div></div><div class="public anchor" id="var-vector-distinct-by"><h3>vector-distinct-by</h3><h4 class="added">added in 0.9.0</h4><div class="usage"><code>(vector-distinct-by key-fn gen)</code><code>(vector-distinct-by key-fn gen opts)</code></div><div class="doc"><pre class="plaintext">Generates a vector of elements from the given generator, with the
guarantee that (map key-fn the-vector) will be distinct.

If the generator cannot or is unlikely to produce enough distinct
elements, this generator will fail in the same way as `such-that`.

Available options:

  :num-elements  the fixed size of generated vectors
  :min-elements  the min size of generated vectors
  :max-elements  the max size of generated vectors
  :max-tries     the number of times the generator will be tried before
                 failing when it does not produce distinct elements
                 (default 10)
  :ex-fn         a function of one arg that will be called if test.check cannot
                 generate enough distinct values; it will be passed a map with
                 `:gen`, `:num-elements`, and `:max-tries` and should return an
                 exception</pre></div><div class="src-link"><a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L824">view source</a></div></div></div></body></html>